{
  "cells": [
    {
      "cell_type": "markdown",
      "source": [
        "# Automated ML\n",
        "\n",
        "In the cell below, import all the dependencies that you will need to complete the project."
      ],
      "metadata": {}
    },
    {
      "cell_type": "code",
      "source": [
        "import argparse\n",
        "import os\n",
        "import joblib\n",
        "from pprint import pprint\n",
        "\n",
        "from azureml.core import Workspace, Experiment, Model\n",
        "from azureml.core.compute import ComputeTarget, AmlCompute\n",
        "from azureml.core.run import Run\n",
        "from azureml.widgets import RunDetails\n",
        "from azureml.train.automl import AutoMLConfig\n",
        "from azureml.data.dataset_factory import TabularDatasetFactory"
      ],
      "outputs": [],
      "execution_count": null,
      "metadata": {
        "gather": {
          "logged": 1598423888013
        },
        "jupyter": {
          "outputs_hidden": false,
          "source_hidden": false
        },
        "nteract": {
          "transient": {
            "deleting": false
          }
        }
      }
    },
    {
      "cell_type": "markdown",
      "source": [
        "## Dataset\n",
        "\n",
        "### Overview\n",
        "In this project we will be creating a classification Automated ML to predict the death event of hearth failure. We will uses twelve features from the dataset which outlined below:\n",
        "- age (int): self explanatory\n",
        "- anaemia (bool): whether there has been a decrease of red blood cells or hemoglobin\n",
        "- creatinine_phosphokinase (int): level of the CPK enzyme in the blood in mcg/L\n",
        "- diabetes (bool): whether the patient has diabetes\n",
        "- ejection_fraction (int): percentage of blood leaving the heart at each contraction\n",
        "- high_blood_pressure (bool): whether the patient has hypertension\n",
        "- platelets (int): platelets in the blood in kiloplatelets/mL\n",
        "- serum_creatinine (float): level of serum creatinine in the blood in mg/dL\n",
        "- serum_sodium (int): level of serum sodium in the blood in mEq/L\n",
        "- sex (int): female or male (binary)"
      ],
      "metadata": {}
    },
    {
      "cell_type": "code",
      "source": [
        "# Data Acquisition\n",
        "ds = TabularDatasetFactory.from_delimited_files(\"https://raw.githubusercontent.com/eparamasari/ML_Engineer_ND_Capstone/main/data/heart_failure_clinical_records_dataset.csv\")"
      ],
      "outputs": [],
      "execution_count": null,
      "metadata": {}
    },
    {
      "cell_type": "code",
      "source": [
        "ws = Workspace.from_config()\n",
        "\n",
        "# Setting up experiment\n",
        "experiment_name = 'ClassificationHearthFailure-AutoML'\n",
        "\n",
        "experiment=Experiment(ws, experiment_name)"
      ],
      "outputs": [],
      "execution_count": null,
      "metadata": {
        "gather": {
          "logged": 1598423890461
        },
        "jupyter": {
          "outputs_hidden": false,
          "source_hidden": false
        },
        "nteract": {
          "transient": {
            "deleting": false
          }
        }
      }
    },
    {
      "cell_type": "code",
      "source": [
        "# Setting up compute cluster\n",
        "compute_name = \"AutoML-Compute\"\n",
        "try:\n",
        "    compute_target = ComputeTarget(ws, compute_name)\n",
        "    print(compute_name+ \" already exist.\")\n",
        "except:\n",
        "    compute_config = AmlCompute.provisioning_configuration(vm_size=\"Standard_DS12_V2\", min_nodes=1, max_nodes=5)\n",
        "    compute_target = ComputeTarget.create(ws, compute_name, compute_config)\n",
        "compute_target.wait_for_completion(show_output=True)\n",
        "\n",
        "print(compute_target.get_status().serialize())\n"
      ],
      "outputs": [],
      "execution_count": null,
      "metadata": {}
    },
    {
      "cell_type": "markdown",
      "source": [
        "## AutoML Configuration\n",
        "\n",
        "In this step we configure the automl settings. We set the timeout to 60 minutes and concurrent iteration to 5 to speed up the process and set accuracy as evaluation metrics to select the best model. \n",
        "\n",
        "We used classification with number of cross validation to 5 in order to minimize the overfitting."
      ],
      "metadata": {}
    },
    {
      "cell_type": "code",
      "source": [
        "# Automl settings here\n",
        "automl_settings = {\n",
        "    \"experiment_timeout_minutes\": 1,\n",
        "    \"max_concurrent_iterations\": 5,\n",
        "    \"primary_metric\": 'accuracy'\n",
        "}\n",
        "\n",
        "# Automl config here\n",
        "automl_config = AutoMLConfig(\n",
        "    task='classification',\n",
        "    compute_target=compute_target,\n",
        "    training_data=ds,\n",
        "    label_column_name='DEATH_EVENT',\n",
        "    n_cross_validations=5,\n",
        "    **automl_settings\n",
        ")"
      ],
      "outputs": [],
      "execution_count": null,
      "metadata": {
        "gather": {
          "logged": 1598429217746
        },
        "jupyter": {
          "outputs_hidden": false,
          "source_hidden": false
        },
        "nteract": {
          "transient": {
            "deleting": false
          }
        }
      }
    },
    {
      "cell_type": "code",
      "source": [
        "# TODO: Submit your experiment\n",
        "remote_run = experiment.submit(automl_config)"
      ],
      "outputs": [],
      "execution_count": null,
      "metadata": {
        "gather": {
          "logged": 1598431107951
        },
        "jupyter": {
          "outputs_hidden": false,
          "source_hidden": false
        },
        "nteract": {
          "transient": {
            "deleting": false
          }
        }
      }
    },
    {
      "cell_type": "markdown",
      "source": [
        "## Run Details\n",
        "\n",
        "OPTIONAL: Write about the different models trained and their performance. Why do you think some models did better than others?\n",
        "\n",
        "In the cell below, use the `RunDetails` widget to show the different experiments."
      ],
      "metadata": {}
    },
    {
      "cell_type": "code",
      "source": [
        "RunDetails(automl_run).show()"
      ],
      "outputs": [],
      "execution_count": null,
      "metadata": {
        "gather": {
          "logged": 1598431121770
        },
        "jupyter": {
          "outputs_hidden": false,
          "source_hidden": false
        },
        "nteract": {
          "transient": {
            "deleting": false
          }
        }
      }
    },
    {
      "cell_type": "code",
      "source": [
        "automl_run.wait_for_completion(show_output=True)"
      ],
      "outputs": [],
      "execution_count": null,
      "metadata": {}
    },
    {
      "cell_type": "markdown",
      "source": [
        "## Best Model\n",
        "\n",
        "In the cell below, we get the best model from the automl experiments and display all the properties of the model.\n",
        "\n"
      ],
      "metadata": {}
    },
    {
      "cell_type": "code",
      "source": [
        "# Getting the best run and model\n",
        "aml_best_run, aml_fitted_model = automl_run.get_output()\n",
        "\n",
        "# Printing the best run\n",
        "print(aml_best_run)"
      ],
      "outputs": [],
      "execution_count": null,
      "metadata": {
        "gather": {
          "logged": 1598431425670
        },
        "jupyter": {
          "outputs_hidden": false,
          "source_hidden": false
        },
        "nteract": {
          "transient": {
            "deleting": false
          }
        }
      }
    },
    {
      "cell_type": "code",
      "source": [
        "# Printing the model details\n",
        "print(aml_fitted_model)"
      ],
      "outputs": [],
      "execution_count": null,
      "metadata": {}
    },
    {
      "cell_type": "code",
      "source": [
        "# Getting all metrics of the best run\n",
        "best_run_metrics = aml_best_run.get_metrics()\n",
        "\n",
        "# Printing all metrics of the best run\n",
        "for metric_name in best_run_metrics:\n",
        "    metric = best_run_metrics[metric_name]\n",
        "    print(metric_name, metric)"
      ],
      "outputs": [],
      "execution_count": null,
      "metadata": {}
    },
    {
      "cell_type": "code",
      "source": [
        "aml_fitted_model.steps[1][1].estimators"
      ],
      "outputs": [],
      "execution_count": null,
      "metadata": {}
    },
    {
      "cell_type": "code",
      "source": [
        "# Saving the best model\n",
        "best_automl_model = aml_best_run.register_model(model_path='outputs/model.pkl', model_name='heart_failure_automl',\n",
        "                        tags = {'Training context': 'Automated ML'},\n",
        "                        properties = {'Accuracy': best_run_metrics['accuracy']})\n",
        "\n",
        "print(best_automl_model)"
      ],
      "outputs": [],
      "execution_count": null,
      "metadata": {
        "gather": {
          "logged": 1598431426111
        },
        "jupyter": {
          "outputs_hidden": false,
          "source_hidden": false
        },
        "nteract": {
          "transient": {
            "deleting": false
          }
        }
      }
    },
    {
      "cell_type": "code",
      "source": [
        "# Listing registered models to verify that the model has been saved\n",
        "for model in Model.list(ws):\n",
        "    print(model.name, 'version:', model.version)\n",
        "    for tag_name in model.tags:\n",
        "        tag = model.tags[tag_name]\n",
        "        print ('\\t',tag_name, ':', tag)\n",
        "    for prop_name in model.properties:\n",
        "        prop = model.properties[prop_name]\n",
        "        print ('\\t',prop_name, ':', prop)\n",
        "    print('\\n')"
      ],
      "outputs": [],
      "execution_count": null,
      "metadata": {}
    },
    {
      "cell_type": "markdown",
      "source": [
        "## Model Deployment\n",
        "\n",
        "In the cell below, register the model, create an inference config and deploy the model as a web service."
      ],
      "metadata": {}
    },
    {
      "cell_type": "code",
      "source": [
        "# Downloading the environment file\n",
        "aml_best_run.download_file('outputs/conda_env_v_1_0_0.yml', 'envFile.yml')\n",
        "\n",
        "# Downloading the scoring file \n",
        "aml_best_run.download_file('outputs/scoring_file_v_1_0_0.py', 'scoreScript.py')"
      ],
      "outputs": [],
      "execution_count": null,
      "metadata": {
        "gather": {
          "logged": 1598431435189
        },
        "jupyter": {
          "outputs_hidden": false,
          "source_hidden": false
        },
        "nteract": {
          "transient": {
            "deleting": false
          }
        }
      }
    },
    {
      "cell_type": "code",
      "source": [
        "from azureml.core.environment import Environment\n",
        "from azureml.core.model import InferenceConfig\n",
        "\n",
        "inference_config = InferenceConfig(entry_script='scoreScript.py',\n",
        "                                   environment=aml_best_run.get_environment())\n",
        "\n",
        "# Deploying\n",
        "from azureml.core.webservice import AciWebservice\n",
        "\n",
        "deployment_config = AciWebservice.deploy_configuration(cpu_cores = 1, memory_gb = 1)\n",
        "service = Model.deploy(ws, \"myservice\", [best_automl_model], inference_config, deployment_config)\n",
        "service.wait_for_deployment(show_output = True)\n",
        "print(service.state)\n",
        "\n",
        "print(service.scoring_uri)\n",
        "\n",
        "print(service.swagger_uri)"
      ],
      "outputs": [],
      "execution_count": null,
      "metadata": {}
    },
    {
      "cell_type": "code",
      "source": [
        "import json\n",
        "\n",
        "# Importing test data\n",
        "data_df = ds.to_pandas_dataframe().dropna()\n",
        "test_df = data_df.sample(5) # data_df is the pandas dataframe of the original data\n",
        "label_df = test_df.pop('DEATH_EVENT')\n",
        "\n",
        "test_sample = json.dumps({'data': test_df.to_dict(orient='records')})\n",
        "\n",
        "print(test_sample)"
      ],
      "outputs": [],
      "execution_count": null,
      "metadata": {}
    },
    {
      "cell_type": "markdown",
      "source": [
        "In the cell below, send a request to the web service you deployed to test it."
      ],
      "metadata": {
        "collapsed": true,
        "gather": {
          "logged": 1598431657736
        },
        "jupyter": {
          "outputs_hidden": false,
          "source_hidden": false
        },
        "nteract": {
          "transient": {
            "deleting": false
          }
        }
      }
    },
    {
      "cell_type": "code",
      "source": [
        "import requests # for http post request\n",
        "\n",
        "# Set the content type\n",
        "headers = {'Content-type': 'application/json'}\n",
        "\n",
        "response = requests.post(service.scoring_uri, test_sample, headers=headers)"
      ],
      "outputs": [],
      "execution_count": null,
      "metadata": {
        "gather": {
          "logged": 1598432707604
        },
        "jupyter": {
          "outputs_hidden": false,
          "source_hidden": false
        },
        "nteract": {
          "transient": {
            "deleting": false
          }
        }
      }
    },
    {
      "cell_type": "code",
      "source": [
        "# Printing results from the inference\n",
        "print(response.text)"
      ],
      "outputs": [],
      "execution_count": null,
      "metadata": {}
    },
    {
      "cell_type": "code",
      "source": [
        "# Printing ground truth labels\n",
        "print(label_df)"
      ],
      "outputs": [],
      "execution_count": null,
      "metadata": {}
    },
    {
      "cell_type": "markdown",
      "source": [
        "In the cell below, print the logs of the web service and delete the service"
      ],
      "metadata": {
        "collapsed": true,
        "gather": {
          "logged": 1598432765711
        },
        "jupyter": {
          "outputs_hidden": false,
          "source_hidden": false
        },
        "nteract": {
          "transient": {
            "deleting": false
          }
        }
      }
    },
    {
      "cell_type": "code",
      "source": [
        "print(service.get_logs())"
      ],
      "outputs": [],
      "execution_count": null,
      "metadata": {
        "jupyter": {
          "outputs_hidden": false,
          "source_hidden": false
        },
        "nteract": {
          "transient": {
            "deleting": false
          }
        }
      }
    },
    {
      "cell_type": "code",
      "source": [
        "service.delete()"
      ],
      "outputs": [],
      "execution_count": null,
      "metadata": {}
    }
  ],
  "metadata": {
    "kernel_info": {
      "name": "python3"
    },
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3"
    },
    "language_info": {
      "name": "python",
      "version": "3.6.9",
      "mimetype": "text/x-python",
      "codemirror_mode": {
        "name": "ipython",
        "version": 3
      },
      "pygments_lexer": "ipython3",
      "nbconvert_exporter": "python",
      "file_extension": ".py"
    },
    "nteract": {
      "version": "nteract-front-end@1.0.0"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 2
}